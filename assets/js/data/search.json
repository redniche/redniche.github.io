[ { "title": "안드로이드앱-브래인매니저", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80/", "categories": "포트폴리오, 메인프로젝트", "tags": "니체, 예찬군, 안드로이드, 앱, SQLite", "date": "2022-03-20 23:03:00 +0900", "snippet": "NeoMindStd/BrainManager 프로젝트깃허브 링크소개사용자가 기억하고자 하는 내용(키워드)을 간격 반복 알고리즘으로 복습시간을 알람. 사용자가 해당 내용을 잊지 않게 하는 안드로이드 앱입니다.기능이 약간 추상적일 수 있는데 간단히 소개하자면 사용자가 키워드를 입력하고 해당 키워드의 설명을 적어넣고 등록하면 그 키워드와 설명에 대한 문제를 알아서 생성해서 복습할 수 있도록 도와줍니다.영어단어, 사람, 기술적인 배움 등등 온갖 외워야 할 것들을 쉽게 외울 수 있도록 도와주는 것입니다!구현을 하면서 가중치를 업데이트 하는 방식의 알고리즘을 사용했는데 문제의 정답률에 따라서 복습을 최적화 하는 등의 기능을 추가로 구현해볼 수 있을 것 같습니다.개발 후기4인 개발 팀이었지만 저와 팀장 둘이서 거의 모든 기능을 구현하기도 하고 여러 버그가 남아 있어 관리적 측면에선 실패한 프로젝트입니다. 하지만 이를 경험하면서 애자일방식 개발과 의사소통의 필요성을 느끼게 되었고 이후 프로젝트들에서 이에서 많은 것들을 피드백하여 개선할 수 있었습니다.요약 내용 인원 4 개발기간 2019.03~2019.06 배포 플레이스토어 링크 성과 플레이스토어 50회 이상 설치 개발환경 범주 스택 언어 개발도구 주요 패키지 실행화면주요 역할설계 아이디어 제안자로서 아키텍처 설계구현 복습 화면 복습 알림 알고리즘(간격 반복 알고리즘) 관계성 설정 푸시 알림 야간모드 SQLite 쿼리 Locale별 언어 처리 안드로이드 버전별 동작 처리애플리케이션 아키텍처" }, { "title": "핑 모니터링 툴 개발", "url": "/posts/%ED%95%91-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%88%B4-%EA%B0%9C%EB%B0%9C/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C#, Ping, 핑툴", "date": "2022-03-20 21:43:00 +0900", "snippet": "redniche/Ping-Monitoring 프로젝트깃허브 링크소개인터넷의 특정 네트워크 기기와의 핑테스트를 위해 만들어진 프로그램입니다.인트라넷 상황에서 내부망을 관제해야할 때 사용하고자 진행했습니다. 하지만 결국 핑 모니터링 툴이기 때문에 모든 환경에서 사용할 수 있습니다.Thread를 사용해 여러 ip주소에 핑테스트를 할 수 있게 개발했는데 덕분에 스레드에 대한 이해를 높일 수 있었습니다.다만 공유자원의 교착상태를 막기 위해 Semaphore를 사용했는데 이 당시에만 해도 async await에 대해 제대로 알지 못하는 상태에서 이를 사용해서 제대로 활용하지 못한 점이 아쉬움으로 남아 있습니다.기술스택 범주 스택 언어 프레임워크 개발 환경 Framework: .Net Framework 4.7.1 IDE: Visual Studio 2019(back up) Language: C#사용법지원기능네트워크 모니터링 망이름 (공백 혹은 Tabs) 1.1.1.1(ip형식) 1.1.1.1(ip형식)과 같이 입력 후 Start 버튼 클릭. Start를 누르면 입력창은 전부 *로 변합니다.핑 모니터링 목록은 열과 행으로 구분되는데 줄바꿈으로 열을 추가합니다.핑상태는 라벨의 색으로 구분합니다.초록색: 핑 100 이하주황색: 핑 200 이하빨간색: 핑 200 초과보라색: 연결불가투명도 조절화면의 투명도를 아래의 스크롤바를 이용해 변경할 수 있습니다.IP 노출 방지화면에 표시된 IP 주소는 모두 *로 처리됩니다.모니터링 정지시에는 비밀번호가 필요합니다. ‘예찬3’3번 틀릴시 프로그램 강제 종료됩니다.비밀번호 갱신 기능은 필요시 업데이트 예정입니다." }, { "title": "웹 디자인-헬스가든", "url": "/posts/%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%97%AC%EC%8A%A4%EA%B0%80%EB%93%A0/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, 웹디자인, Cafe24, 웹호스팅", "date": "2022-03-20 21:43:00 +0900", "snippet": "헬스가든이란?㈜ 바이오앤라이프에서 운영하는 온라인 쇼핑몰입니다.https://blog.naver.com/kwak5336와 같이 홍보용 블로그를 운영하면서 여러 한방제품들을 판매하는 회사입니다.개발 배경제가 학부 4학년 때 교외 국가 근로를 진행하면서 위의 업체에서 근로를 진행했었는데 사장님이 저의 개발 능력으로 홈페이지 재단장을 요청하셔서 진행했습니다.보통 국가 근로를 하면서 이런 일을 하지는 않지만 저는 이것 또한 경험을 넓히고 사회에 공헌하는 기회라 생각하여 잘 만들어 보기 위해 노력했습니다.개요 범주 스택 언어 개발환경 호스팅 결과물사이트 링크: https://health-garden.shop/" }, { "title": "수상기록 모음", "url": "/posts/%EC%88%98%EC%83%81%EA%B8%B0%EB%A1%9D-%EB%AA%A8%EC%9D%8C/", "categories": "포트폴리오, 대외활동", "tags": "니체, 예찬군, 수상기록, 삼성SW아카데미, 아이디어, 공모전", "date": "2022-03-20 18:36:00 +0900", "snippet": "삼성 SW 아카데미 공통 프로젝트 최우수상상장 교부 전수상 요약삼성 청년 소프트웨어 아카데미의 2학기 공통 프로젝트에서Unity 기반의 웹RTC 멀티플레이 게임을 개발해 최우수 팀으로 선정됨.프로젝트 깃https://github.com/redniche/INCRIME개요 인원 5 개발 기간 2022.01.10~ 2022.02.18 개발 환경 요약 UnityNode.js ExpressMySQL 프로젝트 소개 링크   후기 개발을 진행하면서 기술적인 배움 뿐만 아니라 디스코드와 노션을 활용한 정보 공유, 개발 계획 관리, 버그 해결까지 효과적으로 마무리한 프로젝트입니다.이후에 진행하는 프로젝트에서 깃, Jira, 디스코드, 노션 등 여러 도구를 활용한 현업 수준의 프로젝트를 진행하는 것에 도움이 되었습니다.삼성 SW 아카데미 프로젝트 우수상수상 요약삼성 청년 소프트웨어 아카데미에서 1학기 공통 진행 프로젝트인공공데이터를 이용한 HappyHouse 서비스 주제의 프로젝트에서 우수팀으로 선정됨.프로젝트 깃https://github.com/redniche/HappyHouseProject개요 인원 2 개발 기간 2021.11.18 ~ 2021.11.25 개발 환경 요약 Spring BootMySQLVue.js 핵심 기능 Kakao Map, Jsoup 크롤링, 공공데이터 API 후기 일주일의 짧은 기간동안 일정관리, 명세서 기반의 프로젝트 진행, Notion과 Git을 활용한 애자일적인 소프트웨어 개발 등을 경험했습니다.현실에선 항상 시간이 넉넉한 것은 아닐 수 있습니다. 저희는 데드라인이 아주 짧은 프로젝트에서도 유용한 결과물을 만들어내는 역량을 기를 수 있었습니다.삼성 SW 아카데미 1학기 성적우수상수상 요약삼성 청년 소프트웨어 아카데미에서 우수한 성적으로 1학기 교육을 이수함.개요 인원 1 기간 2021.07.07 ~ 2021.11.26 교육 과정 요약 JAVA 알고리즘DBWeb HTML, JavaScript, CSS SPA Framework: Vue.js 후기 삼성 청년 SW 아카데미에 입과하고 상당히 빠르게 시간이 지나갔습니다. 교육 중에 아주 바쁘다는 것을 완전히 체감할 수 있었습니다.저는 게으른 점이 조금 있습니다. 이를 개선하기 위해 삼성의 현업 멘토님들께 질문하고 답변 받은 일정관리 법으로 대략적인 일정을 관리하며 배운 것들을 다시 곱씹는 방식으로 성적을 유지했고 성적 우수상을 받을 수 있었습니다.육군혁신 아이디어 콘테스트 표창수상요약육군혁신 “뿜뿜” 콘테스트에서 창의적인 아이디어, 전투발전소요 제언을 통해 육군에 기여한 공을 인정받아 표창됨.개요 인원 1 기간 2018.06.24 ~ 2021.07.14 공모내용 그리드 컴퓨팅 - 목표: 육군 전술서버의 자산 부족 해결, 24시간 켜져있는 클라이언트 컴퓨터 활용- 내용: 서버 처리를 클라이언트에서 분산 처리하는 기술 제안클라이언트 기반 처리- 목표: 모든 데이터 로직을 서버에서 처리하는 기존 구조 개선- 내용: SSR 방식의 클라이언트를 CSR로 전환 제안 후기 당시 서버 운용 시 문제가 되는 구조를 지적하고 클라이언트 처리를 늘리는 방향의 제안서를 작성했습니다.또한 그리드 컴퓨팅에 대한 논문들을 읽고 해당 기술들의 순차적 도입과 방향을 제안하며 참고문헌으로 활용하여 제안을 뒷받침했습니다.여단장 분들 앞에서 발표를 진행했는데 발표를 할 때 어떻게 청중의 수준에 맞출 수 있을지 고민을 하면서 시각적인 자료를 준비했고 발표를 만족스럽게 진행할 수 있었습니다." }, { "title": "신경망 숫자 인식기", "url": "/posts/%EC%8B%A0%EA%B2%BD%EB%A7%9D-%EC%88%AB%EC%9E%90-%EC%9D%B8%EC%8B%9D%EA%B8%B0/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C#, 신경망, 다층퍼셉트론, 숫자인식기, MNIST", "date": "2022-03-14 23:23:00 +0900", "snippet": "redniche/Neural-Number-Recognition 프로젝트깃허브 링크소개정사각형 데이터패턴으로 이루어진 숫자를 인식하는 다층 퍼셉트론 기반 신경망입니다. 숫자가 아니어도 패턴을 유추해낼 수 있습니다.학습과 질의를 위해 MNIST 데이터셋을 사용하는 것을 추천합니다.대학생 때 알파고가 이세돌을 이기는 것을 보고 AI 기술이 벌써 이만큼 발전했나 느끼곤 어떻게 저런 것을 만들 수 있을지 연구하는겸 군대에서부터 전역하고 제작하게 되었습니다.MNIST 데이터셋 60000개를 학습하고MNIST 데이터셋 10000개의 테스트 데이터에 대해 대략 97%의 정확도를 보입니다.프로젝트 진행기간 2016년 10월~12월, 2018년 11월기술스택Build Environment Framework: .Net Framework 4.7.1 IDE: Visual Studio 2019 Language: C#데이터셋 MNIST in CSV 링크의 train set, test set 같은 형식의 csv 파일 파일명이 정답인 이미지 파일(.png, .jpg, .jpeg 형식) 예시) 1.png, 2.jpg 주요 사용법Help도움말을 보여줍니다.Create신경망을 생성합니다.본 예제에서는 은닉층이 200노드고 출력이 10개(숫자 수)인 이미지(가로세로 28px)를 인식할 수 있는 신경망 객체를 생성합니다.ShowStatus신경망의 상태를 확인합니다. 대략적인 신경망 객체의 정보를 볼 수 있습니다.CsvTraincsv파일로 신경망을 학습시킬 수 있습니다.예시 학습용 csv파일: 링크CsvQuery학습된 신경망 객체를 csv파일로 테스팅할 수 있습니다.csv파일로 신경망에 질의하는 명령입니다.대용량 테스팅을 할 때 활용할 수 있으며 쿼리의 세부 결과는 로그로 남습니다.예시 테스팅용 csv파일: 링크ImageQuery학습된 신경망 객체를 이미지 파일로 테스팅할 수 있습니다.png, jpg, jpeg 파일을 지원합니다. 여러 파일을 한 번에 테스팅 할 수 있습니다.쿼리의 결과가 콘솔창에 그대로 나타납니다.Save신경망 객체를 저장할 수 있습니다.Open저장된 신경망 객체를 로드합니다.예제 테스트 데이터에 대해 대략 97%의 정확도를 보여주는 신경망 객체 파일을 제공합니다.신경망 객체 파일.neu과거 코드제 블로그입니다.블로그 링크" }, { "title": "고교 창원대학교 연계 악보인식 R&amp;E 프로젝트", "url": "/posts/%EA%B3%A0%EA%B5%90-%EC%B0%BD%EC%9B%90%EB%8C%80%ED%95%99%EA%B5%90-%EC%95%85%EB%B3%B4%EC%9D%B8%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C, OpenCV, 창원대학교, 영상인식기술, 악보인식", "date": "2022-03-09 17:54:00 +0900", "snippet": "프로젝트 기술스택 개발 IDE 언어 활용 라이브러리 고등학교제가 2012년 3월부터 2015년 2월까지 3년간 신세를 진 고등학교입니다. 진해에 있는 고등학교인데 진짜 열심히 가르칩니다. 진고다만 같이 입학한 학생들이 이미 서로 친한 경우(중학교-고등학교 같은 지역)가 많기 때문에 타지 학생들은 조금 불편할 수 있습니다 ㅜㅜ 저는 타지에서 입학해 적응에 조금 어려움을 겪고 좋은 일도 나쁜 일도 많았지만 다 소중한 추억으로 남았던 곳이기도 합니다R&amp;amp;E(과학영재 창의연구)를 어떻게 하게 되었는가?2013년에 특이하게 고등학교에서 창원대 영재교육원과 MOU(업무협약: 기사링크)를 맺고 창원대학교와 R&amp;amp;E를 진행하기 시작했는데 이 때 컴퓨터공학부와 연계가 되길래 관심있는 학생들을 대상으로 인원들을 모집했던 경험이 있습니다. 결과는 당시 2학년인 나와 1학년 후배 3명이 팀으로 참가하게 되었습니다.R&amp;amp;E 주제 선정 배경결과적으로 우리는 ‘악보 인식 프로그램’을 제작하는 주제를 선정했습니다.이를 선정한 이유에 대해 당시 결과 보고서를 인용해보자면 현재에 경향에 맞춰 사람들이 유행을 따르게 되어 소외된 분야들도 많이 있다. 우리는 그러한 것들을 조금이나마 해결해 보고자 이번 R&amp;amp;E를 구성하게 되었다. 좀 더 나은 미래를 위해 우리가 걸어야하는 길이 무엇인지, 작은 팀이 얼마나 많은 성과를 낼 수 있는지 알고 싶었다. 근래에 컴퓨터 기술이 발달하며 악보영상을 자동으로 인식하고 연주해 주는 악보 인식(Music score Recognition) 시스템에 관한 연구가 많이 진행되었다. 대부분의 연구들이 상당한 성과를 얻어내었고 높은 가치를 가지고 있다. 하지만 최근 들어 이 시스템에 관한 연구가 드물어지고 있으며 진행이 매우 더디어지고 있다. 악보 자동 인식에 대한 연구는 1960년대 후반부터 시작되었으나, 악보의 복잡성과 다양성으로 인하여 아직까지 모든 형태의 악보를 인식할 수 있는 일반적인 악보 인식 시스템은 존재하고 있지 않으며, 기존의 악보 인식 방법들은 인식 속도가 느리고 인식률이 낮은 단점이 있다.라고 기록되어 있습니다. 정보를 더하자면 당시 고등학생 1, 2학년인 우리들은 컴퓨터 과학에 대해 배경지식이 적었고 할 수 있는 것들 또한 매우 적었습니다.따라서 당시 정성환 지도교수 님에게 C언어에 대한 기초적인 교육을 받았고 배종욱 박사 님이 OpenCV로 연구를 진행하고 있던 영상 인식 기술에서 영감을 받아 이 주제를 선정하게 되었습니다.R&amp;amp;E 활동 내용C, OpenCV 학습당시 지도교수 님에게 교육받았던 내용 중 일부입니다. C언어의 기초 문법, 포인터, 파일 입출력에 대해 교육받았습니다.이후에는 배종욱 박사 님에게 우리의 주제를 위한 OpenCV 교육을 받았는데 대표적으로 아래와 같이 교육받고 실험(실습?)해보며 R&amp;amp;E를 진행했습니다. OpenCV라이브러리를 통해 태극기 출력 OpenCV로 웹캠 연결 및 웹캠을 통한 얼굴 인식 (배종욱 박사님입니다 ㅎㅎ) 악보인식 프로그램 제작 과정주제를 위해 교육받은 내용을 바탕으로 개발을 시작했습니다.당시에 대학교의 실습용 컴퓨터에서만 작업을 했었는데 이제와서 찾아보니 아쉽게도 코드 작업물들이 남지를 않아 아쉬움이 있네요…프로젝트를 위해 다음의 3가지를 처음 기획했고 구현했습니다. 넘버 기능 구현 1 컴퓨터 비전 기술을 이용한 악보에서의 음표 추출 O 2 사람의 눈 대신 카메라를 이용하여 악보영상을 처리 X 3 자동음악 연주 시스템 개발을 위한 기반 △ 음표 추출 시스템 구성도 악보의 전처리 및 잡음제거 악보의 원할한 인식을 위해 원본 이미지에서 이진 영상으로 변환, 모폴로지(팽창-&amp;gt;축소)를 이용해 전처리 잡음이란 검출하고자 하는 것 이외의 모든 것을 말합니다악보영상에서의 잡음으로는 조표, 음자리표, 제목, 가사, 코드, 마디 등 존재 레이블링: 인접한 화소에 번호를 매겨 하나의 그룹으로 만드는 작업레이블링을 통해 일정 크기(넓이)보다 작은 그룹을 제거하여 잡음을 제거 했습니다. 기울어짐 보정 기울어짐을 보정하기 위해서 조금 테크니컬한 방식이 필요했는데 직선을 검출하기 위해서 잡음이 제거된 이진 영상에서 모폴로지를 한 번 더 진행해서 오선을 제거하고 이를 비트 연산을 통해 음표부분만 제거된 화면을 얻었어야 했습니다. 그 후 허프 변환을 활용해 직선의 기울기를 검출 했습니다.그 결과로 우리는 위와 같이 기울기가 보정된 화면을 얻을 수 있었습니다. 오선 인식 및 제거 오선 인식을 해야 이를 제거하고 음표의 위치를 알고 어떤 음표인지 알 수 있기 때문에 오선 인식이 필요했습니다.오선 인식은 OpenCV의 히스토그램를 반환받을 수 있는 calcHist() 함수를 활용해서 진행했습니다. 위와 같이 영상의 가로 방향 픽셀값을 모두 더해 히스토그램을 출력하고 피크값을 찾아내 이를 오선의 수직 좌표로 활용했습니다. 결과적으로 이와 같이 각 줄별로 5개의 수직 좌표를 반환받을 수 있었고 이를 이용해 상하 픽셀값 유무를 체크하여 영역 색을 255로 변환했습니다. 음표 추출 음표가 어떤 것인지 어떤 음표인지 인식하기 위한 음표 추출이 필요 했습니다.음표 추출은 다음의 순서로 진행되었습니다. i. 비음표 제거ii. 잇단음표 분리iii. 음표의 추출 i. 비음표 제거 우선 비음표를 위와 같은 방식으로 제거했습니다.상기의 잡음 제거에서 했던 방식처럼 레이블링을 수행하고 비음표의 경우엔 자주 나오지 않기 때문에 그룹의 픽셀 값의 평균을 구한 뒤 편차치가 큰 것들을 제거하는 방식으로 제거할 수 있었습니다. ii. 잇단음표 분리 현재까지 레이블링은 잇단음표를 하나로 인식합니다. 따라서 이를 분리하기 위해 히스토그램을 한 번 더 사용했습니다. 위와 같이 이미지에서 세로 방향의 히스토그램을 그래프에서 앞 뒤 값으 130% 이상 검출 객체 높이의 60% 이상인 수치를 기준으로 Local Maxima(국부 최대값)를 추출해냈습니다. 여기까지 저희는 프로젝트를 진행했고 이후엔 이 실험과 프로젝트의 결과물로 3 종류의 음악 장르에 각각 10곡을 사용해 테스트를 진행해 보았습니다. 테스트동요 옥수수 하모니카 2. 나무를 심자 3. 보물찾기 4. 다람쥐 5. 졸업식 노래 고기잡이 7. 기찻길 옆 8. 꼬부랑 할머니 9. 바닷가에서 반짝반짝 작은 별찬송가 만복의 근원 하나님 2. 이 천지간 만물들아 3. 거룩하신 하나님 다 감사드리세 5. 복의 근원 강림하사 6. 즐겁게 안식한 날 이 날은 주의 정하신 8. 우리의 주여 9. 오 만세 반석이신 저 해와 달과 별들이발라드 다 줄꺼야 2. 벌써 일년 3. 사랑이 지나가면 4. 오래 전 그날 사랑 빛 6.1 다행이다 7. 다행이다(회전) 8. 너에게로 또 다시 보고싶다 10. 너를 위해프로젝트 회고본 연구는 컴퓨터 비전 기술을 이용해 악보 영상 처리를 연구했습니다.연구과정에서 악보의 인식까지 연구를 진행했고 당시 3가지 장르의 30곡의 임의의 악보에 대하여 약 85.2%의 인식률을 보였습니다.찬송가와 같이 화질이 좋은 경우 약 93% 이상의 인식률을 보였습니다.당시 사회 트렌드에서 조금 벗어난 주제이지만 이러한 기술 또한 발전되어야 전체 사회가 발전할 수 있다고 배종욱 박사님이 말씀해 주셨습니다.덕분에 배종욱 박사 님의 영상처리 논문 관련에서도 도움이 되었다?고 하셨었습니다ㅋㅋ여담으로본 프로젝트를 위해 고등학교 2학년 학업과 동시에 창원대학에 왔다 갔다 하는 시간을 쏟으니 내신 성적이 나빠진 부작용이 있었습니다.하지만 처음으로 C언어가 어떤 것인지, 컴퓨터의 구조가 어떤 것인지 프로그래밍을 제대로 어떻게 하는지 배울 수 있었던 시간이었고 지금와서 이런 경험이 없었다면 제가 이때까지 프로그래밍에 열의를 가지고 계속 살아오지 못했을 것이란 생각이 남습니다.포스트 코멘트정말 과거의 기록을 이제와서 정리해보자니 참 이런저런 생각이 많이 남습니다.특히 프로젝트가 끝나고 난 뒤에 보고서와 발표자료를 준비했었는데이 때 3학년이 되어 학교에서 무언가 시키는 것이 많아 끝까지 함께하지 못한 것이 아쉬웠습니다.최종 결과물은 후배들이 아주 열심히 만들어 주었다고 후일담으로 들었습니다.프로젝트 결과물 파일창원대 R&amp;amp;E 악보인식 프로젝트 최종.pptx감사합니다." }, { "title": "Git 커밋 기록 유지하고 옮기기", "url": "/posts/git-%EC%BB%A4%EB%B0%8B-%EA%B8%B0%EB%A1%9D-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B3%A0-%EC%98%AE%EA%B8%B0%EA%B8%B0/", "categories": "개발, Git", "tags": "니체, 예찬군, 깃, Git, 도구, 깃허브, 깃랩, 커밋, 옮기기, 기록, 기록유지", "date": "2022-03-04 16:22:00 +0900", "snippet": "GitHub, GitLab 등 서로 옮기기도 가능일반적인 옮기기 Bare 클론git clone --bare 해당깃링크cd 클론된 깃 폴더 옮길 리포지토리에 푸시git push --mirror 옮길 리포지토리 깃 링크100MB 이상의 파일이 존재할경우 (Git LFS Storage 사용. 비과금시 1GB제한) https://git-lfs.github.com/ 와 https://rtyley.github.io/bfg-repo-cleaner/ 사이트에 들어가서 다운로드 하기. 복사하고자 하는 저장소(gitlab)의 clone을 생성합니다.git clone --mirror 해당깃링크cd 클론된 깃 폴더 커밋 히스토리 내에서 large file을 찾아 트랙킹 합니다. “*.{zip,jar,mp4}” 중괄호 내의 파일은 트래킹을 할 파일 확장자 목록입니다.(이 확장자가 아닌 파일이 100mb를 넘으면 추가 작성)git filter-branch --tree-filter &#39;git lfs track &quot;*.{zip,jar,mp4}&quot;&#39; -- --all BFG를 이용하여 해당 파일들을 git lfs로 변경합니다. (bfg-1.14.0.jar 파일 다운로드 한 경로 지정.)bfg-1.14.0.jar 사용이 잦을 것 같은 경우 고급시스템설정의 환경변수로 이 경로를 등록하면 편합니다.java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.zip&#39;java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.jar&#39;java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.mp4&#39; 새로운 저장소(github)로 mirror-push를 진행합니다.git push --mirror 옮길 리포지토리 깃 링크위와 같이 BFG와 LFS를 이용해서 깃허브를 옮기려면 깃 LFS 스토리지가 사용되며 이는 깃허브를 기준으론 용량제한 정책에 제한을 받습니다(무료기준 1GB). 모든 커밋내역에서 100MB가 넘는 파일의 변경사항을 추적하기 때문에 파일 표기 용량보다 많이 사용될 수 있습니다.따라서 다음과 같이 하는 방법도 추천드립니다.(100mb 이상의 파일이 히스토리에서 삭제됨)100MB이상 히스토리 모두 삭제 후 옮기기 git bash를 엽니다. 복사하고자 하는 저장소(gitlab)의 bare clone을 생성합니다.git clone --bare 해당깃링크cd 클론된 깃 폴더 ( 100MB 에러가 날 경우 ) 기존 Commit에서 100MB보다 큰 파일의 로그를 강제로 없애줘야 합니다.java -jar [경로]bfg-1.14.0.jar --strip-blobs-bigger-than 100M 새로운 저장소(github)로 mirror-push를 진행합니다.git push --mirror 옮길 리포지토리 깃 링크" }, { "title": "좋은 개발자가 되기 위한 방법론", "url": "/posts/%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%A1%A0/", "categories": "개발, 방법론", "tags": "니체, 예찬군, 좋은개발자, 좋은개발자방법론, 방법론, 해외, 취업", "date": "2022-03-04 15:54:00 +0900", "snippet": "익명의 시니어 분이 제공해주셨습니다목차1 - 문제 해결 방법 3가지 실용적으로 문제 해결하기 공용코드 만들기 코드의 생김새 다듬기 사용자를 위한 코드 짜기 도구를 만들고 개선하기 자동화 하기 질 좋은 문서 남기기 관계 쌓기 동료 사이 신뢰 쌓기 멘토 멘티 찾기 커뮤니티 활동으로 인맥 &amp;amp; 선택의 폭 넓히기 해외 취업 팁실용적으로 문제 해결하기💡 &quot;A 기능을 만들려고 하는데 참고할 만한 프로젝트가 있나요?&quot;&quot;B와 비슷한 기능을 하는 코드가 있나요?&quot;→ 공용코드 만들기 Don’t Repeat Yourself ‘지금 내가 겪는 문제는 동료도 똑같이 겪었다’ 모듈화 오픈소스 활동💡 “기존 코드에 기능을 추가하려는데 너무 걸려요”“버그를 고쳐야하는데 코드를 이해수가 없어요”→ 코드의 생김새 다듬기 “Programs must be written for people to read, and only incidentally for machines to execute”- SICP - 함수 짧게 만들기 변수 이름 잘 짓기 예외 상황 처리아래 두 코드를 서로 비교해보세요func doSomething() { let blah = ... for item in items ( print (item.name) }}var myData: [String: Data]private func somethingElse() -&amp;gt; String { return &quot;Hello World&quot;}func justDoIt() {// whatever..}var myData: [String: Data]func doSomething() { let blah = for item in items { print(item.name) }}func justDoIt() { // whatever..}private func somethingElse() -&amp;gt; String { return &quot;Hello World&quot;}💡 “앱이 / 웹사이트가 사용하기 너무 어려워요””A 기능과 B 기능 중 뭐가 더 나은지 모르겠어요”→ 사용자를 위한 코드 짜기 내가 만든걸 쓸 사람의 입장이 되어보기 백오피스, 플랫폼, 프론트엔드 등 다른 사용자 특성 사이드 프로젝트 출시해보기 사용자와 접점이 있는 모든 곳에 주목도구를 만들고 개선하기💡 “반복 작업에 시간을 너무 많이 낭비해요&quot;“매일/매주/매달 반복되는 작업이 너무 지루해요”→ 자동화 하기 소프트웨어 배포 단계 지속적 통합 / 지속적 배포💡 “테스트용 계정을 만들어야 하는데 어떻게 하나요?&quot;“이렇게 결정하게 된 근거가 뭔가요? 미팅에서 어떤 논의가 오고 갔나요?”→ 질 좋은 문서 남기기 사내 시스템 사용법 회의록, Action Items 코드 아키텍처 정보, 노하우 축적관계 쌓기💡 “A를 새롭게 도입하고 싶은데 동료들을 어떻게 설득해야 하나요?&quot;“B가 더 좋은 방법/기술 인거 같은데 선임은 C를 하자고 해요&quot;→ 동료 사이 신뢰 쌓기 절대적으로 우세한 기술이란건 거의 없다 진심으로 동료의 성장과 행복에 신경 쓰기 팀워크💡 “더 성장하고 싶은데 어떻게 해야할까요?&quot;“개발을 더 잘하고 싶어요&quot;→ 멘토 &amp;amp; 멘티 찾기 가까운 곳에서 시작해서 먼 곳으로 탐색 원격근무의 시대: 온라인 멘토 누군가의 멘토 되기💡 “이직을 하고 싶어요&quot;“개발자가 저 혼자라 외롭고 재미가 없어요”→ 커뮤니티 활동으로 인맥 &amp;amp; 선택의 폭 넓히기 소모임 / 컨퍼런스 발표 Google Developer Expert 내부 추천채용(referral) 관심사, 의견 공유해외 취업 팁지역/국가 선택, 정보 많이 수집(1) 그 나라에서의 삶은 어떨까?나랑 잘 맞을까?(2) 외국인에게 가장 중요한것: 비자(신분)싱가폴: Employment Pass미국: Visa (H-1B, E2, L, O-1 등)경력 쌓기 및 회사 지원(1) 경력이 많을수록 유리하나 극복초년생부터 링크드인 관리(2) 내부 직원 추천으로 지원" }, { "title": "블록체인 [이더리움을 통해 맛보기] (4)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-4/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 예찬군, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE, 체인링크,, Chainlink", "date": "2022-02-27 19:34:00 +0900", "snippet": "좀 더 어려운 스마트 컨트랙 직접 만들어보기 (feat. Chainlink)지난 포스트에서 스마트 컨트랙을 Solidity로 작성하는 방법을 배웠습니다.그렇다면 이번엔 좀 더 구체적인 기능들이 있는 스마트 컨트랙을 작성하는 것을 해보도록 하겠습니다.우선 앞으로 이 포스트 및 이외의 여러 스마트컨트랙 작성을 위해 꼭 필요한 배경지식을 잠깐 설명하겠습니다.Solidity의 기능 추가 설명난수스마트컨트랙트에서 여러 서비스(게임, 추첨 등)를 제공하기 위해 난수가 필요한 경우들이 있습니다.하지만 블록체인 상에서 난수를 발생시키는 것은 여러 위험성과 고려사항이 있습니다. 난수를 생성하는 방법 2가지 keccak256 사용 위 방법은 일반적으로 초심자들이 스마트컨트랙에서 난수를 발생시키기 위해 사용하는 방식입니다.다만 이 방식은 근본적으로 완전한 난수가 아니라 “의사 난수”이므로 외부에서 이를 예측하거나 조작하여 많은 피해가 발생한 사례들이 많습니다. Chainlink VRF 솔루션 사용 위의 keccak256을 이용한 난수에서 발생하는 문제들을 해결하기 위해 이더리움 Layer2 솔루션인 Chainlink를 이용하는 방법입니다.이는 탈중앙화된 클라이언트들을 통해 완전히 예측 불가능한 난수를 반환하는 솔루션을 제공합니다.다만 이를 사용하기 위해선 Chainlink의 모듈을 Solidity 내에 포함해야하며 이 솔루션의 난수를 반환받는 함수를 호출하기 위해 LINK라는 토큰이 추가적으로 필요합니다. 난수의 생성엔 여러 방법들이 있겠으나 대표적인 두 방법을 확인해 보았습니다.우리는 이제 난수를 생성하고 활용하는 함수를 포함한 스마트 컨트랙을 만들어서 솔리디티를 배워봅시다근데 이렇게까지 억지로 기능을 넣어야만 했냐…?기부금을 모으는 스마트컨트랙 만들어보기 요구사항 (토글) FundRaising 개발환경 : Remix IDE 기능 설명 일회성으로 동작하는 모금 컨트랙트 일정기간 동안만 이더를 지불하여 모금에 참여할 수 있음 모금 현재 모금액 확인 모금액 수령 기능 랜덤한 기부자의 주소와 기부금을 반환 (의사 난수 사용) 난수 값 요청 (Chainlink VRF 사용) 난수 값 수신 시 이로 랜덤한 기부자의 주소와 기부금을 이벤트로 반환 (Chainlink VRF 사용) 소스 파일 레이아웃 파일 생성 (FundRaising.sol) 라이선스 명시 version pragma 명시 import 선언 (체인링크 관련) contract 선언 생성자 선언 contract가 배포될 때 호출되는 특수 함수 생성자 매개변수 추가 및 상태 변수에 저장 체인링크 VRF를 사용하기 위한 기본 매개변수 추가 address vrfCoordinator, address link, bytes32 keyHash, uint256 fee 사용 VRFConsumerBase(vrfCoordinator, link) 활용 컨트랙트 배포 시 모금 기간과 모금액 수령자를 지정하도록 변경 uint duration - 몇 초 동안 모금이 유효한지 의미 (3600 = 1시간) 정수형 연산자 ‘+’ 현재 타임 스탬프 + duration을 fundRasingCloses의 값으로 지정 block.timestamp - 현재 블록의 유닉스 타임스탬프 값 상태 변수 추가 최소 모금액 지정 기준 : 0.01ether 이더리움 기본 단위 wei 10^18wei = 1ether 1e16==0.01 ether == 10**16 단위 wei, ether등 ** : 지수 연산자 종료 시점 지정 모금 받을 주소 지정 Chainlink VRF를 사용하기 위한 s_keyHash 지정 Chainlink VRF를 사용하기 위해 사용할 가스량 지정 필수 함수 모금 - fund 현재 모금액 - currentCollection 모금액 수령 - withdraw 랜덤한 기부자의 주소와 기부금을 반환 (의사 난수 사용) - selectRandomFunder 난수 값 요청 (Chainlink VRF 사용) - selectRandomFunder2 난수 값 수신 시 이로 랜덤한 기부자의 주소와 기부금을 이벤트로 반환 (Chainlink VRF 사용) - fulfillRandomness fund() 요구사항 0.01 ether 이상으로 모금에 참여할 수 있다. 이더를 받을 수 있는 payable 함수 msg.value 트랜잭션에 얼마를 보냈는 지 알 수 있는 전역 변수 유효성 체크 전송한 이더가 최소 금액 조건을 만족하는지 판별 지정된 모금 시간 이내에만 참여할 수 있다. 조건문 if 논리형 변수 : bool 논리 연산자 : ==, !=, &amp;amp;&amp;amp;, | - 모금 유효 시간인지 판별 - 유효성 체크 함수 require(판별문, “에러 메시지”); 판별문이 true가 아닌 경우 “에러 메시지” 출력 후 함수 바로 종료 if문을 사용하는 것 보다 require를 사용하는 것이 훨씬 경제적이다. 모금이 완료되면 모금자를 저장한다. 주소형 address 이더리움 주소를 저장할 수 있는 자료형 초기값은 0x0 - msg.sender 메시지 송신자를 알 수 있는 전역변수 - 자료형의 배열 uint[4] fixedArray; uint[] dynamicArray; push() : 배열의 가장 뒤에 요소 추가 currentCollection() 요구사항 현재까지 모금된 금액을 누구나 확인할 수 있다. 함수의 반환문 작성 address(this).balance; return address(this).balance; - view 상태 변수에 변화를 가하지 않고 읽기만 하는 함수 withdraw() 요구사항 지정된 수령자만 호출할 수 있다. 이더 전송이 일어나는 payable함수 유효성 체크: 수령자가 맞는 지 확인 모금 종료 이후에만 호출할 수 있다. 유효성 체크: 모금이 종료되었는 지 확인 수령자에게 컨트랙트가 보유한 이더를 송금한다. 함수 modifier 작성 address의 멤버: balance, transfer 컨트랙트가 보유한 이더 &amp;lt;address&amp;gt;.balance 요청 주소에게 컨트랙트 보유 이더 송금 &amp;lt;address payable&amp;gt;.transfer(uint256 amount) selectRandomFunder 요구사항 keccak256를 활용하여 난수를 생성한다. 가스가 덜 생기도록 view로 작성 해당 함수가 안전한지 확인 모금자 배열 내에서 랜덤으로 모금자 주소와 해당 주소의 기부금 액수를 반환한다. 누구든지 요청 가능 selectRandomFunder2 요구사항 Chainlink VRF를 활용하여 Chainlink에 난수 값을 요청한다. 스마트컨트랙의 생성자만 호출할 수 있다. 유효성 체크: 스마트 컨트랙 생성자가 맞는 지 확인 스마트컨트랙이 가진 Link 토큰이 충분해야 호출할 수 있다. 유효성 체크: 가스로 필요한 Link 토큰의 양이 충분한지 확인한다. fulfillRandomness 요구사항 Chainlink VRF에서 난수값을 수신했을 때 동작한다. 모금자 배열 내에서 랜덤으로 모금자 주소와 해당 주소의 기부금 액수를 반환한다. 스마트컨트랙 내부에서만 호출 가능 Solidity 코드 (from Gist)리믹스로 위 코드 테스트 해보기체인링크 VRF(selectRandomFunder2)실행 결과스마트 컨트랙의 이벤트로 결과를 확인할 수 있다.이번 포스트에선 Solidity로 구체적인 기능을 가진 스마트 컨트랙을 작성해보았습니다.내용이 조금 어려울 수 있으나 코드와 주석을 잘 보시면 좀 더 심화적인 학습이 가능하리라 생각합니다.감사합니다." }, { "title": "블록체인 [이더리움을 통해 맛보기] (3)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-3/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 예찬군, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE", "date": "2022-02-25 01:28:00 +0900", "snippet": "솔리디티 (Solidity)지난 포스트에선 Remix IDE에서 솔리디티 예제 파일을 컴파일 하고 배포하는 것을 해 보았습니다.오늘 할 것은 앞서 한 것들을 바탕으로 실제로 솔리디티를 배우고 소스를 코딩하는 것을 목표로 할 것입니다.솔리디티의 구조지난 사용했었던 예제 .sol 파일을 라인별로 분석해 솔리디티의 기본 구조를 알아봅시다.1 라인: 소스코드의 라이선스를 GPL-3.0으로 명시3 라인: Version Pragma: 소스코드가 이용하는 컴파일러 버전 명시 Sematic versioning을 따르고 있습니다.major.minor.patch ^(캐럿 연산자): ‘이상’ ← 이하 이상 할 때 그 이상입니다.9 라인: 컨트랙트의 범위를 나타내는 부분으로 중괄호로(28라인과 함께) 감싸져 있는 것을 보실 수 있습니다.11라인: 상태 변수(State Variable)이 선언되어 있습니다.State Variable 블록체인(contract storage)에 값이 저장되는 변수 상태 변수의 접근 제어자(Visibility)를 external, public, priavte와 같이 지정 가능 기본형, 고조체, 배열 등 다양한 자료형이 존재17라인: 함수(Function)이 선언되어 있습니다.Function 컨트랙트 단위의 기능(해당 스마트컨트랙이 할 수 있는 기능) 매개 변수, 제어자, 반환값 지정 가능 함수 내부서 상태 변수의 값을 변경하거나 읽을 수 있음 (Read&amp;amp;Write)솔리디티 문법기본형 Primitives 타입 논리형bool: true or false 정수형uint: unsigned integerint: signed integer 8 ~ 256 bit를 표현할 수 있으며, uint는 uint256과 같습니다 주소형address: 이더리움의 주소를 표현 바이트형bytes# or byte[]: 데이터를 바이트로 표현할 수 있습니다접근 제어자 Visibility   private internal public external 설명 - 컨트랙트 내에서만 접근 가능 - 현재 컨트랙트와 자식 컨트랙트에서 접근 가능 - 현재 컨트랙트, 자식 컨트랙트, 외부 컨트랙트 및 주소에서 접근 가능 - 외부 컨트랙트와 주소에서 접근 가능 (내부 접근 불가) State Variables O X O O Functions O O O O public으로 되어 있으면 외부 컨트랙트에서 해당 상태 변수를 바로 조회할 수도 있습니다.Solidity 예제// SPDX-License-Identifier: GPL-3.0pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract ParentTest { // State variables 테스트 string private privateVar = &quot;private variable test&quot;; string internal internalVar = &quot;internal variable test&quot;; string public publicVar = &quot;public variable test&quot;; // Private function function privateFunc() private pure returns (string memory) { return &quot;private test function called&quot;; } // Private fucntion을 테스트할 fucntion function testPrivateFunc() public pure returns (string memory) { return privateFunc(); } // Internal function function internalFunc() internal pure returns (string memory) { return &quot;internal test function called in Parent Contract&quot;; } // Internal fucntion을 테스트할 fucntion function testInternalFunc() public pure virtual returns (string memory) { return internalFunc(); } // Public functions 테스트 function publicFunc() public pure returns (string memory) { return &quot;public test function called&quot;; } // External functions function externalFunc() external pure returns (string memory) { return &quot;external test function called&quot;; }}contract ChildTest is ParentTest { // Internal function call be called inside child contracts. function testInternalFunc() public pure override returns (string memory) { return internalFunc(); } function testInternalFuncInChild() public pure returns (string memory){ // return privateFunc(); //에러 발생 return internalFunc(); }} 타 언어와 다른 특징으로는 함수의 return타입을 뒤에 선언한다는 점 internal 함수는 자식에서 호출이 가능 public 함수는 자식 뿐만 아닌 외부에서도 모두 호출이 가능 이 예시를 컴파일 해서 배포(배포 방법은 이전 포스트 참고)한 후 각 함수를 호출해보면 private 와 public과 같은 Visibility를 잘 확인하실 수 있습니다.자주 쓰는 자료형(타입)배열 Array 고정 길이, 가변 길이 배열이 존재합니다 배열형 자료구조 제어 방법index에 접근push, pop, delete 사용 함수 내에서 로컬 변수로 배열을 사용하기 위해서는 고정 길이로 선언해야 합니다 인덱스는 0부터 시작합니다 Solidity 예제 // SPDX-License-Identifier: GPL-3.0pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Array { // 고정 길이 배열, 모든 원소는 0으로 초기화 됨 uint[10] public fixedSizeArr; // 가변길이 배열 uint[] public arr; // 초기화 안 한 상태 uint[] public arr2 = [1, 2, 3]; // 같은 라인에서 초기화도 같이 한 상태 // 배열의 접근(조회) 방법 function get(uint i) public view returns (uint) { return arr2[i]; } // 새 원소를 배열에 추가 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function push(uint i) public { arr.push(i); } // 배열에서 마지막 원소 삭제 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function pop() public { arr.pop(); } // delte 지시자를 사용하지만 실상은 특정 인덱스의 원소를 0으로 초기화시키는 동작을 함 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function remove(uint index) public { delete arr[index]; } // 배열의 크기를 반환하는 함수 function getLength() public view returns (uint) { return arr.length; } // 전체 배열을 반환하는 함수 function getArr() public view returns (uint[] memory) { return arr; } // 고정길이의 5칸짜리 배열을 생성하고 그것을 반환해주는 함수 function createArray() external pure returns (uint[] memory){ // create array in memory, only fixed size can be created uint[] memory a = new uint[](5); return a; }} 매핑 Mapping (자주 쓰임)예시를 통해 Mapping에 대해 다음을 배워봅시다. 매핑형 선언 접근, 추가, 삭제 매핑에 저장된 key의 목록을 얻을 수 있는 방법을 제공하지 않습니다Solidity 예제// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Mapping { // 매핑의 선언 // address(주소)를 uint로 매핑 mapping(address =&amp;gt; uint) public addrToUint; // 매핑 내의 키 값으로 값을 연결함 // 만약 해당하는 키가 없으면, 해당 타입의 기본 값을 반환함, 0. function get(address _addr) public view returns (uint) { return addrToUint[_addr]; } // 매핑 내 address 키에 해당하는 unit 값을 업데이트 function set(address _addr, uint _i) public { addrToUint[_addr] = _i; } // 매핑 내 address 키에 해당하는 unit 값을 기본 값으로 초기화, 0. function reset(address _addr) public { delete addrToUint[_addr]; } // 이런식으로 매핑의 값을 uint 배열 때처럼 불러오는 것은 불가능하다(에러) // 왜냐하면 매핑은 내부적으로 키를 저장해 놓는 것이 아니라 키 자체의 sha3해시에 의해 계산된 // 상태 메모리(state memory)에 저장된 값만 저장한다. 따라서 매핑의 조회는 원래 키가 제공되어야만 이를 계산하여 // 조회할 수 있게 구현되어 있기에 반드시 key가 있는 상태로 조회되어야 한다. // function getMapping() public view returns (mapping memory){ // return addrToUint; // }}사용자 선언 자료형 - Struct다음을 예시를 활용해 배워봅시다. Struct는 한글로 구조체라고도 합니다. 여러 자료형을 하나의 관점으로 묶어서 관리하고자 할 때 선언합니다. (마치 C언어 같음)struct Todo{ string todoText; bool isComplete;} 구조체의 Array, Mapping 의 값으로 지정이 가능합니다. 구조체 생성, 접근, 변경 함수 안에서 struct 상태 변수 참조 방법Solidity 예제// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Struct { //구조체의 선언 struct Todo { string text; bool boolean; } // 구조체의 배열 선언 Todo[] public structTodoArray; // 주소를 Todo 타입으로 매핑한다. mapping(address =&amp;gt; Todo) public addrToStruct; // 새로운 구조체를 생성해서 구조체 배열에 푸시 // 접근방식 1 function create1(string memory _text) public { structTodoArray.push(Todo(_text, false)); } // 접근방식 2 function create2(string memory _text) public { structTodoArray.push(Todo({text: _text, boolean: false})); } // 접근방식 3 function create3(string memory _text) public { Todo memory s; s.text = _text; structTodoArray.push(s); } // 구조체 배열 내 특정 인덱스의 Todo 인스턴스의 text를 변경 function updateText(uint _index, string memory _text) public { Todo storage s = structTodoArray[_index]; s.text = _text; } // 불리언(Boolean) 값을 토글 function updateBoolean(uint _index) public { Todo storage s = structTodoArray[_index]; bool current = s.boolean; s.boolean = !current; }}함수 function예제를 통해 다음을 배워봅시다. 함수 선언 방법 매개변수 유무, 반환 값 유무 view, pure 함수의 특징 2개 이상의 값을 반환하도록 선언// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Function { //여러 상태변수들 선언 uint public num = 1; uint public a = 1; string public s = &quot;hello solidity&quot;; bool public b = true; // 파라미터와 리턴값이 없는 함수 function addOne() public { num++; } // 하나의 파라미터와 리턴값이 있는 함수 function addNumber(uint x) public returns (uint) { num += x; return num; } // view - 상태변수들을 변경하지 않는다, 단순히 읽음. 가스가 안듬. function addAndReturn(uint x) public view returns (uint) { return num + x; } // pure - 상태 변수를 읽거나 수정하지 않음. 가스가 안듬. function add(uint x, uint y) public pure returns (uint) { return x + y; } // 여러 값들을 리턴하는 방법. function returnMany() public view returns (uint, string memory, bool) { return (a, s, b); }}Data location 배열이나 구조체처럼 복합타입(Complex type)의 경우 데이터의 위치(Data location)에 대한 어노테이션(Annotation)이 추가됩니다. 메모리(memory)와 저장소(storage), 콜데이터(calldata)로 구분되는 데이터의 위치는 각 타입별로 기본값이 있으나 필요에 따라서 재지정이 가능합니다. 메모리(memory) : 함수 내에서 임시로 데이터(storage 등)를 저장 할 때 사용하는 변수이다. 임시 데이터(temporary data) 저장소(storage) : 블록체인 상에 영구이 저장된다. 영구데이터(permanent data) 영역에 데이터가 저장되므로 다른 키워드에 비해 큰 비용을 초래한다. 콜데이터(calldata) : 리턴 파라미터를 제외한 외부 함수의 파라미터들, 데이터를 호출하고 메모리와 비슷하게 동작 → 함수에 전달되는 매개 변수처럼 변경 불가능하고 임시적인 데이터 저장 영역임. Solidity 예제 // SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract HamburgerFactory { struct Hamburger { string name; string status; } Hamburger[] Hamburgers; //햄버거를 초기화하고 배열에 햄버거를 넣음 function createHamburger(string memory _text) public { Hamburgers.push(Hamburger({name: _text, status: &quot;not eat&quot;})); } function eatStorageHamburger(uint _index) public { // storage로 선언된 myHamburger로 햄버거의 인덱스를 참조전달함 Hamburger storage myHamburger = Hamburgers[_index]; myHamburger.status = &quot;eaten&quot;; //따라서 수행되고 나면 값이 바뀜 } function eatMemoryHamburger(uint _index) public view{ // 메모리 변수의 선언 Hamburger memory myHamburger = Hamburgers[_index]; myHamburger.status = &quot;eaten&quot;; //상태가 변해도 블록체인에는 영향X. } function getStatusHamburger(uint _index) public view returns(string memory){ return Hamburgers[_index].status; //해당 값이 memory 형태에 담겨서 return됨 }} 제어문제어문은 타 언어와 매우 유사하므로 예시를 위주로 설명하겠습니다.조건문 If-Else//함수 내에서만 사용 가능함.if(x &amp;lt; 10){ return 0;} else if (x &amp;lt; 20){ return 1;} else { return 2;}// 삼항 연산자 return _x &amp;lt; 10 ? 1 : 2;반복문 for / while//함수 내에서만 사용 가능함.for (uint i = 0; i &amp;lt; 10; i++) { if (i == 3) { continue; } if (i == 5) { break; }}uint i;//함수 내에서만 사용 가능함.while (i &amp;lt; 10){ i++;} 반복문 사용시 주의사항: 이더리움은 튜링 완전머신으로 반복문을 제대로 지원하지만 함수를 수행할 때 수행 시간에 따라 가스가 발생하기 때문에 로직을 비효율적으로 하면 많은 돈이 소모될 수 있습니다.화폐 단위 화폐 단위에는 ether와 wei, gwei가 있습니다. 이더리움 내에선 소수점을 허용하지 않기 때문에 이와 같은 방식을 사용합니다.// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract EtherUnits { uint public oneWei = 1 wei; uint public oneGwei = 1 gwei; uint public oneEther = 1 ether; // 1 wei is equal to 1 bool public isOneWei = 1 wei == 1; // 1 ether is equal to 10^18 wei bool public isOneEther1 = oneEther == 1e18; // 1 ether is equals to 10^9 gwei. bool public isOneEther2 = oneEther == 10**9 * oneGwei; // 1 gwei is equals to 10^9 wei. bool public isOneGwei = oneGwei == 10**9 * oneWei;}" }, { "title": "프로그래머스 Level2 카카오프렌즈 컬러링북", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level2-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%94%84%EB%A0%8C%EC%A6%88-%EC%BB%AC%EB%9F%AC%EB%A7%81%EB%B6%81/", "categories": "알고리즘, 프로그래머스", "tags": "니체, 예찬군, 알고리즘, 프로그래머스, BFS, DFS, 탐색, 카카오, LEVEL2", "date": "2022-02-23 03:08:29 +0900", "snippet": "카카오 프렌즈 컬러링북 출처 https://programmers.co.kr/learn/courses/30/lessons/1829문제 설명출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다.여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다.(영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.)그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자.위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다.입력 형식 입력은 그림의 크기를 나타내는 m과 n, 그리고 그림을 나타내는 m × n 크기의 2차원 배열 picture로 주어진다. 제한조건은 아래와 같다. 1 &amp;lt;= m, n &amp;lt;= 100 picture의 원소는 0 이상 2^31 - 1 이하의 임의의 값이다. picture의 원소 중 값이 0인 경우는 색칠하지 않는 영역을 뜻한다. 출력 형식 리턴 타입은 원소가 두 개인 정수 배열이다. 그림에 몇 개의 영역이 있는지와 가장 큰 영역은 몇 칸으로 이루어져 있는지를 리턴한다.예제 입출력 m n picture answer 6 4 [[1, 1, 1, 0], [1, 2, 2, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 3], [0, 0, 0, 3]] [4, 5] 예제에 대한 설명예제로 주어진 그림은 총 4개의 영역으로 구성되어 있으며, 왼쪽 위의 영역과 오른쪽의 영역은 모두 1로 구성되어 있지만 상하좌우로 이어져있지 않으므로 다른 영역이다. 가장 넓은 영역은 왼쪽 위 1이 차지하는 영역으로 총 5칸이다.문제 풀이picture[rol][col]==-1이 아닌 지점을 기준으로 같은 값의 영역을 계속 -1로 만들면서 탐색하는 bfs 알고리즘을 사용했다.문제는 프로그래머스 자체에 오류가 있어서 배열을 복사하는 것이 아니라 참조 전달을 하면 제출 시 에러가 발생하는 문제가 있었다.분명 틀린 것 하나도 없어보이는데 계속 에러가 나길래 질문하기 게시판을 봤음.. 잃어버린 의미 없던 고뇌의 1시간import java.util.*;class Solution { static Queue&amp;lt;int[]&amp;gt; queue; public int[] solution(int m, int n, int[][] picture) { int numberOfArea = 0; int maxSizeOfOneArea = 0; int[][] cpic = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { cpic[i][j] = picture[i][j]; } } queue = new LinkedList&amp;lt;&amp;gt;(); int temp = 0; for(int i =0, j=0; i&amp;lt;m; i++){ for(j=0; j&amp;lt;n; j++){ temp = bfs(i,j,m,n, cpic); if(temp &amp;gt; 0) { numberOfArea++; maxSizeOfOneArea = Math.max(temp, maxSizeOfOneArea); } } } int[] answer = new int[2]; answer[0] = numberOfArea; answer[1] = maxSizeOfOneArea; return answer; } // picture[rol][col]==-1이 아닌 지점을 기준으로 같은 값의 영역을 계속 -1로 만들면서 탐색하는 bfs private int bfs(int row, int col, int m, int n, int[][] picture){ if(picture[row][col] == 0) return 0; int thisColor = picture[row][col]; queue.offer(new int[]{row,col}); picture[row][col] = 0; int sum = 0; int dr[] = {-1, 1, 0, 0}; int dc[] = {0, 0, -1, 1}; while(!queue.isEmpty()){ int[] pos = queue.poll(); int trow = pos[0], tcol = pos[1]; sum++; for(int d=0; d&amp;lt;4; d++){ int nr = trow + dr[d]; int nc = tcol + dc[d]; if(nr == -1 || nr == m || nc == -1 || nc == n || picture[nr][nc] == 0 || picture[nr][nc] != thisColor) continue; queue.offer(new int[]{nr,nc}); picture[nr][nc] = 0; } } return sum; }}" }, { "title": "블록체인 [이더리움을 통해 맛보기] (2)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-2/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE, 테스트넷, Besu, RPC", "date": "2022-02-23 00:27:47 +0900", "snippet": "스마트 컨트랙(Smart Contract)이란?1990년대에 Nick Szabo가 소개한 개념으로 기존의 문서 계약을 디지털 형식으로 바꾼 것입니다.디지털 형식으로 명시된 서약(commitment)들의 집합이라고 할 수 있음!전혀 스마트하지 않아서 다소 잘못된 용어지만 자리잡음블록체인에서의 정의불변의 컴퓨터 프로그램 컴퓨터 프로그램 불변(immutable)한 번 배포되면 변경 불가 결정적(deterministic) 실행한 결과가 모두 같음. EVM(Ethereum virtual machine) 위에서 동작 탈중앙화된 World Computer 동일한 상태를 유지Smart Contract를 작성하는 언어 Solidity(가장 대중화되어 있고 상대적으로 사용하기 쉬움) LLL Viper AssemblySmart Contract의 배포와 호출Smart Contract Code → 컴파일 → EVM Bytecode, ABI(Application Binary Interface) in JSON → 트랜잭션 생성→{... from: deployer&#39;s address, to: 0x, data: bytecode,...}→ 서명 → Sending transaction 스마트 컨트랙에는 바이트코드가 담기게 됩니다..스마트컨트랙 또한 주소가 생성되는데 이를 컨트랙트 주소(CA: Contract Address)라고 합니다.실제로 스마트 컨트랙을 Solidity로 작성해 보기 위해 우리는 Remix IDE를 사용합니다.Remix IDE로 실제 배포 및 호출 해보기 이더리움 재단이 제공하는 스마트컨트랙을 쉽게 사용할 수 있게 웹페이지에서 제공하는 통합 개발 환경스마트 컨트랙 배포우리는 여기서 기본적으로 제공되는 예제 contract인2번 영역에서 contract 폴더 내의 1_Storage.sol 을 활용해보겠습니다!컴파일은 1번 영역의 2번째 버튼을 사용합니다.이더리움은 2015년에서부터 엄청 많은 업데이트가 있었는데 그러는 중 컴파일러 문법이 달라지기도 하고 내부적인 구현이 달라지기도 했습니다.따라서 컴파일러의 버전을 pragma solidity 라는 지시자로 언제부터 어디까지의 버전을 따른다는 것을 명시합니다. 컴파일을 문제없이 완료하면 왼쪽과 같이 컨트랙트가 나타나게 됩니다.만약 문법상의 에러가 난다면 터미널 영역에서 에러가 표시됨!컴파일 완료시 → ABI와 Bytecode가 생성됨. 1번 영역에서 다시 파일 익스플로러로 넘어오면 컴파일한 sol파일이 있는 폴더에 artifacts 라는 폴더가 생성되고 컴파일 결과를 확인할 수 있습니다!여기까지 스마트 컨트랙의 배포 과정 중 컴파일로 ABI 생성까지 이루어진 것!그럼 이걸 실제로 배포를 해야합니다 이렇게 컴파일러에서 초록색으로 체크가 되어 있으면 실제로 배포를 할 수 있다는 것인데 실제 배포하기 전에 간단하게 클라이언트의 가상 환경에서 테스트를 해볼 수 있게 제공합니다. (ENVIRONMENT 부분)JavaScript VM 선택시 총 10개의 테스트해볼 수 있는 이더리움 계정을 준다.[1번] 디플로이(Deploy) 선택시 해당 스마트 컨트랙이 [2번] 배포(가상환경에/_)되는 것을 볼 수 있습니다.또한 3번을 보면 배포가 완료되어 가스비가 나간것을 확인할 수 있습니다.그리고 터미널에서 배포 부분을 크게 보면 어떤 지갑에서 나갔고 가스를 얼마 썼고 등의 확인을 할 수 있습니다.그럼 여기까지 스마트컨트랙의 배포 과정이 완료된 것이고 우리는 테스트만을 목적으로 한 것이기 때문에 아직 이더리움 메인넷을 활용하진 않은 것입니다.→ 브라우저 기반 가상환경에서 즉각적으로 처리되는 테스트를 한 것배포된 컨트랙트의 주소값은 왼쪽 아래에서 확인 가능그렇다면 이젠 배포가 끝났으니 배포된 스마트 컨트랙을 호출할 차례입니다.스마트 컨트랙 호출 Deployed Contracts 열기각각의 store 버튼과 retrieve 버튼이 각 우리가 컴파일한 1_Storage.sol의 function을 가리킨다는 것을 알 수 있습니다여기에서 retrieve 버튼을 눌러보시면 number의 숫자를 get할 수 있습니다.자바에서 get, set 메서드를 작성하는 것처럼 그러한 동작을 하는 함수라는 것을 알 수 있습니다.아래쪽의 decoded output을 보시면 0이라는 숫자가 받아진 것을 보실 수 있습니다.우리의 코드에선 number를 단순 선언만 해줬었는데 0이라는 값이 초기화 되어 있다는 것도 알 수 있죠.또한 이런 retrieve 함수는 호출했을 때 가스가 들지 않지만이렇게 값을 바꾸는 함수를 호출할 경우 가스가 사용되게 됩니다. (맨 아래 함수의 호출 결과 상세)→ 전세계의 컴퓨터에서 해당 값을 바꾸라는 얘기가 되므로 일을 시키는데에는 가스가 필요함!이것이 단순한 컴퓨터랑은 무엇이 다른가?→ 한 번 값을 1000으로 바꾸고 나면 다시 스마트 컨트랙으로 값을 바꾸기 전까진 전세계의 컴퓨터들이 이 값을 1000 증명하기 때문에 불변의 속성을 가집니다.모든 것을 프로토콜대로만 제어할 수 있다! 라는 것입니다.우리는 스마트컨트랙 배포를 끝마쳤으니 이제 배포한 사람뿐만 아니라 이 스마트 컨트랙을 아예 다른 제 3자가 활용할 수 있는데배포한 스토리지에서 컨트랙트 주소를 복사하고 이를 삭제한 후 다른 계정으로도 똑같이 테스트 할 수 있습니다.이와 같이 이더리움 주소를 바꿨고 100 ether가 그대로 있지만At Address버튼을 통해 컨트랙트 주소를 추가하고 아래에서 배포된 컨트랙트를 다시 불러올 수 있습니다.그리고 여기서 retrieve를 하면 예전에 저장했던 값인 1000이 보이는 것을 확인하실 수 있습니다.여기까지 블록체인 [이더리움을 통해 맛보기] (2) 였습니다.감사합니다.해보면 좋은 것들Remix에서 3_Ballot.sol 배포해보기상태 변수의 의미 알기 chairman, proposals 변수를 호출해보고 어떤 값이 할당되어 있는지 알기함수 및 변수 호출하기 아직 사용하지 않은 계정을 선택해 3_Ballot.sol 배포한 컨트랙트의 delegate() 함수 호출해보기 호출자(계정)를 변경하고 proposals의 index중 하나를 입력하고 vote()를 호출해보기 2에서 호출한 계정의 voters 정보 확인해보기3_Ballot을 Ropsten 테스트넷에 배포하기 Remix환경과 MetaMask를 이용하여 Ropsten 네트워크에 3_Ballot.sol 컨트랙트를 배포해보기" }, { "title": "블록체인 [이더리움을 통해 맛보기] (1)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-1/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 개발, 이더리움, 블록체인, 트랜잭션, 테스트넷, Besu, RPC", "date": "2022-02-22 01:31:34 +0900", "snippet": "1. 이더리움, 트랜잭션우리의 목적은 빠르게 이더리움을 이해하고 실사용을 해보는 것입니다.이더리움은 온라인상에서 인터넷으로 이어진 노드들로(여러 컴퓨터) 유지되고 있는 분산 데이터베이스의 일종이라 생각하면 되는데이더리움 메인넷에서 접속되는 클라이언트 종류들의 통계는 다음과 같습니다. 여기서 클라이언트란? 네트워크 노드로 참여하는 끝단을 말함 RPC(Remote Procedure Call)요청을 송신하고 결과를 수신받는 엔드포인트임 클라이언트들은 여러 종류가 있는데 우리가 여기서 테스트를 해볼 클라이언트는 Besu입니다.Besu는 이더리움의 클라이언트 소프트웨어를 개조해 퍼블릭 및 프라이빗 네트워크 방식의 사용 모두를 위해 기업 친화적으로 설계된 클라이언트라고 합니다. 프라이빗 네트워크 공개되어 있는 클라이언트 소프트웨어로 프라이빗 네트워크 구축 가능 besu는 엔터프라이즈 환경에 맞게 개량된 하이퍼렛저의 이더리움 프로젝트 우리는 이제 이를 직접 사용해보기 위해 테스트넷을 사용해볼 것인데퍼블릭 네트워크가 이제 진짜 현금성 가치를 가지는 거래가 이루어지는 네트워크라고 한다면테스트넷은 테스트용으로 완전히 분리된 별도의 네트워크입니다. (그리고 이더 테스트넷은 이더 가격이 무료임!)그 중에서 우린 Ropsten 테스트넷에서 요청, 트랜잭션을 처리해볼 예정입니다.2. Ropsten 실습 환경 준비MetaMask 지갑 지갑이란? 블록체인 네트워크를 사용할 수 있도록 계정의 개인키(private key)를 관리하는 프로그램 개인키로 사인(sign)하여 트랜잭션을 보냄 계정 생성 절차(내부 원리) 계정 생성 절차는 [Mastering Ethereum] 3장 키와 주소, 이 포스트를 참고하시면 도움이 될 것 같습니다.간단 정리 개인키 생성 256bit의 무작위 숫자 -&amp;gt; 64자리 타원곡선전자서명 알고리즘(ECDSA, secp256) Keccak-256 hashing 마지막 20Byte를 떼서 계정주소로 사용 계정주소 완성 이 포스트의 목적을 위해지갑과 네트워크를 쉽게 사용하려면 우선 메타마스크의 설치 및 설정과정들이 필요합니다. 메타마스크 확장 프로그램 설치(Chrome) &amp;gt; Ropsten 테스트넷 네트워크 연결을 위한 준비 테스트넷 옵션 활성화 이 옵션 활성화 하면 이더리움 메인넷 클릭시 다른 테스트 네트워크가 보인다. 여기서 Ropsten 테스트 네트워크를 클릭하자 Faucet으로 ETH받기 초록 버튼을 누르면 ETH가 들어옴3. 실제로 RPC 보내고 결과 수신 받아보기이제 사전 준비가 모두 끝났습니다! 실제로 지갑으로 거래가 가능한 상태입니다.여기서 메타마스크의 기능을 십분 활용하기 위해 이더리움 프로바이더를 사용할 것 입니다. 프로바이더(Provider)란? 클라이언트를 통해 이더리움 네트워크에 접근할 수 있도록 제공된 Javascript 객체(Object) 이더리움 Provider로 RPC 요청하기(실습 부분 크롬 메타마스크 확장프로그램이 깔려있는 상태에서 F12 Console창에서 ethereum이란 키워드를 쳐보시면 확인하실 수 있습니다. 메타마스크 Docs이 Console창에서 사용 가능한 모든 메타마스크 명령어는 메타마스크 DOCS에서 제공되고 있습니다.우리가 여기서 봐야할 것은 이더리움 프로바이더의 메서드입니다.이제 여기서 명시되어 있는 방법대로 이더리움의 맨 마지막 블럭의 번호를 한 번 조회해보겠습니다.ethereum .request({ method: &quot;eth_blockNumber&quot;, params: [], }) .then((result) =&amp;gt; { console.log(result); }) .catch((error) =&amp;gt; { // If the request fails, the Promise will reject with an error. });parseInt(&quot;0xb70b6d&quot;, 16);결과가 잘 나오네요. 이더리움 프로바이더에서 RPC를 제대로 송신하고 수신을 받아냈습니다.수신된 값은 16비트로 표현된 값이므로 parseInt를 통해 해석해줘야 합니다여기서 Promise로 되어 있는 결과값은 비동기적인 메서드를 호출할 때 값을 받아온다는 일종의 약속을 말하는 것인데이 게시글에서 다룰 내용은 아닌 것 같고 관련해서 더 궁금하신 분들은 찾아보시면 좋을듯 합니다.물론 이런 단순한 것들 이외에도wallet_getPermissions로 메타마스크의 권한을 얻고 eth_sendTransaction으로 트랜잭션을 보낼 수도 있습니다.더 많은 것들을 해보고 싶으신 분들은메타마스크 DOCS와메타마스크 API 놀이터를참고하시면 좋을듯 합니다.감사합니다." } ]
